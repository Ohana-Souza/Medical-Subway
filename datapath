library IEEE;
use IEEE.STD_LOGIC_1164.all;
use IEEE.NUMERIC_STD.all;

entity Datapath is
    port (
        DP_Clock : in std_logic;
        DP_Reset : in std_logic;
        DP_Reset_Emerg : in std_logic;
        DP_TecladoAndar : in std_logic_vector(2 downto 0);
        DP_TecladoQuarto : in std_logic_vector(3 downto 0);
        DP_Porta : in std_logic;
        DP_ENVIAR : in std_logic;
        DP_CodigoLiberacao : in std_logic_vector(2 downto 0);
        DP_SensorPeso : in std_logic_vector(8 downto 0);
        DP_Temp_Start : in std_logic;
        DP_Temp_Reset : in std_logic;
        DP_Emerg_Start : in std_logic;
        DR_Emerg_SigOUT : out std_logic;
        DR_Tecnico : out std_logic;
        DR_PortaAberta : out std_logic;
        DR_PortaFechada : out std_logic;
        DR_CHEGOU : out std_logic
    );
end entity;

architecture arch of Datapath is

    signal SIG_A_Destino : std_logic_vector(2 downto 0);
    signal SIG_Q_Destino : std_logic_vector(3 downto 0);
    signal SIG_A_Atual : std_logic_vector(2 downto 0);
    signal SIG_Q_Atual : std_logic_vector(3 downto 0);
    signal SIG_Tempo: std_logic;
    signal SIG_Peso : std_logic_vector(8 downto 0);
    signal SIG_CodigoLiberacao : std_logic_vector(2 downto 0);
    signal SIG_Temporizador : std_logic;

    component Temporizador is
        generic (
            frequencia : integer := 1000;
            tempo : integer := 30 -- Valor da temporização em segundos
        );
        port (
            TEMP_Clock : in std_logic;
            TEMP_Start : in std_logic;
            TEMP_Reset : in std_logic;
            TEMP_SigOUT : out std_logic
        );
    end component;

    component Registrador is
        generic (
            W : integer := 4 -- largura do registrador (número de bits)
        );
        port (
            REG_Clock : in std_logic; -- clock
            REG_Reset : in std_logic; -- reset
            REG_Enable : in std_logic; -- enable
            REG_DataIN : in std_logic_vector(W - 1 downto 0); -- dado de entrada
            REG_DataOUT : out std_logic_vector(W - 1 downto 0) -- dado de saída
        );
    end component;

begin

    -- Temporizador para monitorar o tempo de entrega
    INST_Temporizador : Temporizador
    generic map(
        frequencia => 1000,
        tempo => 30)
    port map(
        TEMP_Clock => DP_Clock,
        TEMP_Start => DP_Temp_Start,
        TEMP_Reset => DP_Temp_Reset,
        TEMP_SigOUT => SIG_Temporizador
    );

    -- Registradores para armazenar os valores de andar e quarto
    INST_Reg_A_Destino : Registrador
    generic map(W => 3)
    port map(
        REG_Clock => DP_Clock,
        REG_Reset => DP_Reset,
        REG_Enable => DP_ENVIAR,
        REG_DataIN => DP_TecladoAndar,
        REG_DataOUT => SIG_A_Destino
    );

    INST_Reg_Q_Destino : Registrador
    generic map(W => 4)
    port map(
        REG_Clock => DP_Clock,
        REG_Reset => DP_Reset,
        REG_Enable => DP_ENVIAR,
        REG_DataIN => DP_TecladoQuarto,
        REG_DataOUT => SIG_Q_Destino
    );

    -- Comparadores para verificar a chegada ao destino
    process(DP_Clock)
    begin
        if rising_edge(DP_Clock) then
            if DP_Reset = '1' then
                SIG_A_Atual <= (others => '0');
                SIG_Q_Atual <= (others => '0');
                DR_CHEGOU <= '0';
            else
                if DP_ENVIAR = '1' and DP_Porta = '1' then
                    DR_PortaFechada <= '1';
                    DR_PortaAberta <= '0';
                    if SIG_A_Atual = SIG_A_Destino and SIG_Q_Atual = SIG_Q_Destino then
                        DR_CHEGOU <= '1';
                    else
                        -- Lógica para mover a cápsula
                        SIG_A_Atual <= SIG_A_Destino;
                        SIG_Q_Atual <= SIG_Q_Destino;
                    end if;
                else
                    DR_PortaFechada <= '0';
                    DR_PortaAberta <= '1';
                    DR_CHEGOU <= '0';
                end if;
            end if;
        end if;
    end process;

    -- Lógica para tratar emergência
    process(DP_Clock)
    begin
        if rising_edge(DP_Clock) then
            if DP_Reset_Emerg = '1' then
                DR_Emerg_SigOUT <= '0';
                DR_Tecnico <= '0';
            elsif SIG_Temporizador = '1' then
                DR_Emerg_SigOUT <= '1';
                DR_Tecnico <= '1';
            end if;
        end if;
    end process;

end architecture;
